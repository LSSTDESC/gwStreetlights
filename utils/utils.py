import numpy as np
import bilby as bb
from astropy.time import Time
import pandas as pd
import matplotlib.pyplot as plt
import os
import re
import healpy as hp

def mag_log_normal_dist(sigma,num_pix):
    """
    Generate a median-centered negative log-normal random field.

    This function draws ``num_pix`` samples from a log-normal distribution
    with logarithmic standard deviation ``sigma``, negates the values, and
    shifts the distribution such that its median is exactly zero. The result
    is a skewed, strictly non-positive random field with a well-defined
    central reference level.

    Such distributions are useful for modeling magnitude-like perturbations,
    extinction fluctuations, or other asymmetric noise processes in which
    downward deviations are more probable than upward ones.

    Parameters
    ----------
    sigma : float
        Logarithmic standard deviation of the underlying log-normal
        distribution.
    num_pix : int
        Number of random samples (pixels) to generate.

    Returns
    -------
    counts : ndarray
        Array of length ``num_pix`` containing the median-centered,
        negative log-normal samples.
    min_val : float
        Minimum value of ``counts``.
    max_val : float
        Maximum value of ``counts``.

    Notes
    -----
    The distribution is constructed as:

    1. ``X ~ LogNormal(mean=0, sigma)``
    2. ``counts = -X``
    3. ``counts = counts - median(counts)``

    which guarantees that ``median(counts) = 0`` and that the distribution
    remains skewed toward negative values.
    """
    counts = -np.random.lognormal(mean=0,sigma=sigma,size=num_pix)
    counts -= np.median(counts)
    return counts,np.min(counts),np.max(counts)

def perBand_mag_distribution(LSST_bands,limitingMags,sigma,nside):
    """
    Generate per-band, per-pixel limiting magnitude maps with log-normal scatter.

    This function constructs HEALPix-resolution maps of limiting magnitude
    perturbations for each LSST band by drawing a median-centered, negative
    log-normal random field and adding it to a fiducial limiting magnitude.
    The result is a set of spatially varying depth maps that mimic realistic,
    skewed variations in survey depth across the sky.

    Parameters
    ----------
    LSST_bands : iterable of str
        Iterable of LSST band identifiers (e.g., ``["u", "g", "r", "i", "z", "y"]``).
    limitingMags : float or ndarray
        Fiducial limiting magnitude(s) to which the stochastic perturbations
        are added. If an array is provided, it must be broadcastable to the
        HEALPix pixel count corresponding to ``nside``.
    sigma : float
        Logarithmic standard deviation of the underlying log-normal distribution
        used to generate per-pixel magnitude perturbations.
    nside : int
        HEALPix NSIDE parameter defining the map resolution. The number of
        pixels is computed as ``hp.nside2npix(nside)``.

    Returns
    -------
    band_limit_arrs : dict
        Dictionary mapping each band to a NumPy array of length
        ``hp.nside2npix(nside)`` containing the per-pixel limiting magnitudes.
    band_limit_min_arrs : dict
        Dictionary mapping each band to the minimum perturbation applied in
        that band (i.e., the minimum value drawn from the log-normal field).
    band_limit_max_arrs : dict
        Dictionary mapping each band to the maximum perturbation applied in
        that band (i.e., the maximum value drawn from the log-normal field).

    Notes
    -----
    The per-pixel perturbations are generated by ``mag_log_normal_dist`` and
    are median-centered such that the median limiting magnitude in each band
    remains equal to the fiducial ``limitingMags``.
    """
    band_limit_arrs = {}
    band_limit_min_arrs = {}
    band_limit_max_arrs = {}
    num_pix = hp.nside2npix(nside)
    for band in LSST_bands:
        counts,min_counts,max_counts = mag_log_normal_dist(sigma,num_pix)
        band_limit_arrs[band] = limitingMags[band]+counts
        band_limit_min_arrs[band] = min_counts
        band_limit_max_arrs[band] = max_counts
    return band_limit_arrs,band_limit_min_arrs,band_limit_max_arrs

def trueZ_to_photoZ(true_z,year,modeled=False):
    if modeled:
        prefactor=0.01
    else:
        prefactor=0.04
    time_term = np.sqrt(10/year)
    z_adjust = np.random.normal(loc=true_z,scale=prefactor*(1+true_z)*time_term,size=len(true_z))
    return z_adjust

def GCR_filter_overlord(year, LSST_bands,e_dict,v_dict,airmass=1.2,
                        z_max=1.2,z_min=None,mag_scatter=0.15,nside=128):
    
    # The magnitude limiting cut
    limiting_mags = GCR_mag_filter_from_year(year, LSST_bands,e_dict,v_dict,airmass)

    band_limit_dict,band_limit_min_dict,band_limit_max_dict = perBand_mag_distribution(LSST_bands,limiting_mags,mag_scatter,nside)
    
    # Add the magnitude limiting filter
    filters = []
    for band in LSST_bands:
        filters.append(f"mag_true_{band}_lsst_no_host_extinction<{limiting_mags[band]+band_limit_max_dict[band]}") # limiting_mags has been swapped for band_limit_max_dict here

    # Add the redshift filter
    filters = GCR_redshift_filter(filters,z_max,z_min)

    return filters,band_limit_dict

def GCR_redshift_filter(filt,z_max,z_min=None):
    filt.append(f"redshift_true<{z_max}")
    if z_min!=None:
        filt.append(f"redshift_true>{z_min}")
    return filt

def GCR_mag_filter_from_year(year, LSST_bands,e_dict,v_dict,airmass=1.2):
    limiting_mags = {}
    for band in LSST_bands:
        C_m,m_sky,theta_eff,k_m = getLSSTBandParameters(band)
        limiting_mags[band] = LSST_mag_lim(C_m,m_sky,theta_eff,e_dict[band]*v_dict[band]*year,k_m,airmass)
    
    return limiting_mags

def LSST_mag_lim(C_m,m_sky,theta_eff,t_vis,k_m,X):
    '''
    C_m is the band dependent parameter
    m_sky is the sky brightness (AB mag arcsecâˆ’2)
    theta_eff is the seeing (in arcseconds)
    t_vis is the exposure time (seconds)
    k_m is the atmospheric extinction coefficient
    X is air mass
    '''
    return C_m + 0.5 * (m_sky-21) + 2.5*np.log10(0.7/theta_eff)+1.25*np.log10(t_vis/30)-k_m*(X-1)

def getLSSTBandParameters(band):
    # Band dict in the form of band: [C_m,m_sky,theta_eff,k_m]
    # From eq. 6 of Ivecic 2019
    bandDict = {"u":[23.09,22.99,0.92,0.491],
                "g":[24.42,22.26,0.87,0.213],
                "r":[24.44,21.20,0.83,0.126],
                "i":[24.32,20.48,0.80,0.096],
                "z":[24.16,19.60,0.78,0.069],
                "y":[23.73,18.61,0.76,0.170],
               }
    return bandDict[band.lower()]

def O4DutyCycles(detector):
    """
    A function to return the O4b duty cycles, based on a detector supplied
    Duty cycles taken from https://observing.docs.ligo.org/plan/
    """
    
    if detector=="H1":
        return 0.65
    elif detector=="L1":
        return 0.8
    elif detector=="V1":
        return 0.7
    else:
        raise ValueError("Detector {} is not one of 'H1', 'L1', or 'V1'".format(detector))
        return

def detectorListing(obsRun="O4"):
    """
    A function to return a list of interferometers, based on their duty cycles
    """

    if obsRun=="O4":
        dutyFunc=O4DutyCycles
    else:
        raise ValueError("Observing run {} not yet supported for computing duty cycles.".format(obsRun))
        return
    
    detList = []
    for detector in ["H1","L1","V1"]:
        if np.random.random()<dutyFunc(detector):
            detList.append(detector)
    return detList

def get_source_model(source_model_name="BBH"):
    """
    Returns a source model from bilby.gw.source based on the provided model name.

    Parameters:
        source_model_name (str): The name of the source model to retrieve.
                                 Options include "BinaryBlackHole", "BinaryNeutronStar", etc.

    Returns:
        class: The corresponding source model class (e.g., BinaryBlackHole).

    Raises:
        ValueError: If the source model name is not recognized.
    """
    source_models = {
        "BBH": bb.gw.source.lal_binary_black_hole,   # Binary Black Hole model
        "BNS": bb.gw.source.lal_binary_neutron_star,   # Binary Neutron Star model
        # "NSBH": bb.gw.source.NeutronStarBlackHole  # Neutron Star-Black Hole model
    }

    if source_model_name not in source_models:
        raise ValueError("Invalid source model '{}'. Choose from {}.".format(source_model_name,list(source_models.keys())))

    return source_models[source_model_name]

def get_next_available_dir(base_dir):
    """
    Checks if a directory exists, and if it does, finds the next available numbered version,
    starting from base_dir_0.

    Parameters:
        base_dir (str): The base directory name (e.g., "run").

    Returns:
        str: The next available directory name.
    """
    # Pattern to find existing numbered directories (e.g., run_0, run_1)
    base_pattern = re.escape(base_dir) + r"_(\d+)$"
    existing_numbers = []

    # Check all directories in the parent folder
    parent_dir = os.path.dirname(os.path.abspath(base_dir))
    for entry in os.listdir(parent_dir):
        match = re.match(base_pattern, entry)
        if match:
            existing_numbers.append(int(match.group(1)))

    # Determine the next available number, starting from 0
    next_number = max(existing_numbers, default=-1) + 1
    return "{}_{}".format(base_dir,next_number)

def fakeGeoCentTime():
    """
    A function to generate a fake geocentric time between 2020-2022 (inclusive)
    returns the geocentric time in unix form
    The time is between the start-end time of O4b
    """
    times = ['2024-04-03T00:00:00', '2025-06-04T00:00:00']
    tArr = Time(times, format='isot', scale='tcg')
    return bb.core.prior.Uniform(tArr[0],tArr[1]).sample(1).unix[0]

def makeGeoCentTime(time):
    return Time(time, format='isot', scale='tcg')

def constraintToUniform(priorDict):
    """
    A function to convert any priors in the prior dictionary from bb.core.prior.base.Constraint types to bb.core.prior.prior.Uniform types.
    """
    # Turning entries in the prior dictionary from Constraint type to Uniform over the constraint range
    for i,k in zip(priorDict.keys(),priorDict.values()):
        if type(k) ==bb.core.prior.base.Constraint:
            priorDict[i] = bb.core.prior.Uniform(k.minimum,k.maximum)
            
    return priorDict

def get_merger_prior(merger_type="BBH"):
    """
    Returns a prior dictionary for a given gravitational wave merger type.

    Parameters:
        merger_type (str): The type of merger prior to load.
                          Options include "BBH" (binary black hole),
                          "BNS" (binary neutron star), and "NSBH" (neutron star-black hole).

    Returns:
        bilby.gw.prior.BBHPriorDict or related prior dictionary.

    Raises:
        ValueError: If the merger type is not recognized.
    """
    merger_priors = {
        "BBH": bb.gw.prior.BBHPriorDict,   # Binary Black Hole
        "BNS": bb.gw.prior.BNSPriorDict,   # Binary Neutron Star
        # "NSBH": bb.gw.prior.NSBHPriorDict  # Neutron Star-Black Hole
    }

    if merger_type not in merger_priors:
        raise ValueError("Invalid merger type '{}'. Choose from {}.".format(merger_type,list(merger_priors.keys())))

    return merger_priors[merger_type]()

    